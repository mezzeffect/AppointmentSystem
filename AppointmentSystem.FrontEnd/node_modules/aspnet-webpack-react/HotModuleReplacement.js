"use strict";
function addReactHotModuleReplacementBabelTransform(webpackConfig) {
    var moduleConfig = webpackConfig.module;
    var moduleRules = moduleConfig.rules // Webpack >= 2.1.0 beta 23
        || moduleConfig.loaders; // Legacy/back-compat
    if (!moduleRules) {
        return; // Unknown rules list format
    }
    moduleRules.forEach(function (rule) {
        // Allow rules/loaders entries to be either { loader: ... } or { use: ... }
        // Ignore other config formats (too many combinations to support them all)
        var loaderConfig = rule.use // Recommended config format for Webpack 2.x
            || rule.loader; // Typical config format for Webpack 1.x
        if (!loaderConfig) {
            return; // Not a supported rule format (e.g., an array)
        }
        // Allow use/loader values to be either { loader: 'name' } or 'name'
        // We don't need to support other possible ways of specifying loaders (e.g., arrays),
        // so skip unrecognized formats.
        var loaderNameString = loaderConfig.loader
            || loaderConfig;
        if (!loaderNameString || (typeof loaderNameString !== 'string')) {
            return; // Not a supported loader format (e.g., an array)
        }
        // Find the babel-loader entry
        if (loaderNameString.match(/\bbabel-loader\b/)) {
            // If the rule is of the form { use: 'name' }, then replace it
            // with { use: { loader: 'name' }} so we can attach options
            if (rule.use && typeof loaderConfig === 'string') {
                loaderConfig = rule.use = { loader: loaderConfig };
            }
            var configItemWithOptions = typeof loaderConfig === 'string'
                ? rule // The rule is of the form { loader: 'name' }, so put options on the rule
                : loaderConfig; // The rule is of the form { use/loader: { loader: 'name' }}, so put options on the use/loader
            // Ensure the config has an 'options' (or a legacy 'query')
            var optionsObject = configItemWithOptions.options // Recommended config format for Webpack 2.x
                || configItemWithOptions.query; // Legacy
            if (!optionsObject) {
                // If neither options nor query was set, define a new value,
                // using the legacy format ('query') for compatibility with Webpack 1.x
                optionsObject = configItemWithOptions.query = {};
            }
            // Ensure Babel plugins includes 'react-transform'
            var plugins = optionsObject['plugins'] = optionsObject['plugins'] || [];
            var hasReactTransform = plugins.some(function (p) { return p && p[0] === 'react-transform'; });
            if (!hasReactTransform) {
                plugins.push(['react-transform', {}]);
            }
            // Ensure 'react-transform' plugin is configured to use 'react-transform-hmr'
            plugins.forEach(function (pluginConfig) {
                if (pluginConfig && pluginConfig[0] === 'react-transform') {
                    var pluginOpts = pluginConfig[1] = pluginConfig[1] || {};
                    var transforms = pluginOpts.transforms = pluginOpts.transforms || [];
                    var hasReactTransformHmr = transforms.some(function (t) { return t.transform === 'react-transform-hmr'; });
                    if (!hasReactTransformHmr) {
                        transforms.push({
                            transform: 'react-transform-hmr',
                            imports: ['react'],
                            locals: ['module'] // Important for Webpack HMR
                        });
                    }
                }
            });
        }
    });
}
exports.addReactHotModuleReplacementBabelTransform = addReactHotModuleReplacementBabelTransform;
